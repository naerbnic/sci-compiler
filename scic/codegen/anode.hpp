#ifndef ANODE_HPP
#define ANODE_HPP

#include <cstddef>
#include <cstdint>
#include <optional>

#include "scic/codegen/list.hpp"
#include "scic/codegen/output.hpp"
#include "scic/listing.hpp"

namespace codegen {

struct ANode;

class FixupContext {
 public:
  virtual ~FixupContext() = default;

  virtual bool HeapHasNode(ANode const* node) const = 0;
  virtual void AddRelFixup(ANode const* node, std::size_t ofs) = 0;
};

struct ANode : TNode {
  // An ANode (assembly node) is the construct generated by compiling a portion
  // of the parse tree of the module.  It contains the essential information
  // to generate the actual object code for the module.  The nodes are kept
  // in an AList.

  virtual ~ANode() = default;

  virtual size_t size() const;
  // Returns the number of bytes of object code generated
  // by the node.  This may change for a given node - for
  // example a branch node may change from a word to a byte
  // length branch because of optimizations.

  virtual size_t setOffset(size_t ofs);
  // Sets the 'offset' property of the node to the offset
  // passed, and (using size()) returns the offset of the
  // byte following the node.

  // Try to shrink the node to a smaller size.  Returns true if
  // the node was shrunk, false if it was not.
  virtual bool tryShrink();

  virtual void list(ListingFile* listFile) const;
  // Writes a representation of the node to the listing file.

  // Adds fixups to the fixup_ctxt, if needed for this instruction.
  virtual void collectFixups(FixupContext* fixup_ctxt) const;

  virtual void emit(OutputWriter*) const;
  // Emits the object code for the node to the output file.

  virtual bool contains(ANode const* node) const;

  virtual bool optimize();
  // Applies some optimizations to the node.  This is not
  // really implemented for each node type yet -- most
  // optimization is done in OptimizeProc() in optimize.cpp.

  std::optional<size_t> offset;  // offset of node in file
};

struct ANOpCode : ANode
// This is the generic class for an opcode taking no parameters.  Opcodes
// requiring parameters are subclassed from this.  The property 'op' contains
// the opcode.
{
  ANOpCode() = default;
  ANOpCode(uint32_t o);

  size_t size() const override;
  void list(ListingFile* listFile) const override;
  void emit(OutputWriter*) const override;

  uint32_t op;  // type of operator
};

}  // namespace codegen

#endif