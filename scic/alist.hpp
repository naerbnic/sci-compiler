//	alist.hpp
// 	definitions for assembly

#ifndef ALIST_HPP
#define ALIST_HPP

#include <cstddef>
#include <cstdint>
#include <memory>
#include <optional>
#include <utility>

#include "scic/list.hpp"
#include "scic/listing.hpp"

struct ANode;
class OutputFile;

class FixupContext {
 public:
  virtual ~FixupContext() = default;

  virtual bool HeapHasNode(ANode* node) const = 0;
  virtual void AddRelFixup(ANode* node, std::size_t ofs) = 0;
};

struct ANode : TNode {
  // An ANode (assembly node) is the construct generated by compiling a portion
  // of the parse tree of the module.  It contains the essential information
  // to generate the actual object code for the module.  The nodes are kept
  // in an AList.

  virtual ~ANode() = default;

  virtual size_t size();
  // Returns the number of bytes of object code generated
  // by the node.  This may change for a given node - for
  // example a branch node may change from a word to a byte
  // length branch because of optimizations.

  virtual size_t setOffset(size_t ofs);
  // Sets the 'offset' property of the node to the offset
  // passed, and (using size()) returns the offset of the
  // byte following the node.

  virtual void list(ListingFile* listFile);
  // Writes a representation of the node to the listing file.

  // Adds fixups to the fixup_ctxt, if needed for this instruction.
  virtual void collectFixups(FixupContext* fixup_ctxt);

  virtual void emit(OutputFile*);
  // Emits the object code for the node to the output file.

  virtual bool contains(ANode* node);

  virtual bool optimize();
  // Applies some optimizations to the node.  This is not
  // really implemented for each node type yet -- most
  // optimization is done in OptimizeProc() in optimize.cpp.

  std::optional<size_t> offset;  // offset of node in file
};

struct ANOpCode : ANode
// This is the generic class for an opcode taking no parameters.  Opcodes
// requiring parameters are subclassed from this.  The property 'op' contains
// the opcode.
{
  ANOpCode() = default;
  ANOpCode(uint32_t o);

  size_t size() override;
  void list(ListingFile* listFile) override;
  void emit(OutputFile*) override;

  uint32_t op;  // type of operator
};

template <class T>
class AListBase {
 public:
  // AList (assembly list) is a list of ANodes (assembly nodes).

  // Return the number of bytes of code generated by the opcodes
  // in this list.
  size_t size() {
    size_t s = 0;
    for (auto it = iter(); it; ++it) s += it->size();
    return s;
  }

  size_t length() {
    size_t s = 0;
    for (auto it = iter(); it; ++it) s++;
    return s;
  }

  void list(ListingFile* listFile) {
    for (auto it = iter(); it; ++it) it->list(listFile);
  }

  void collectFixups(FixupContext* fixup_ctxt) {
    for (auto it = iter(); it; ++it) it->collectFixups(fixup_ctxt);
  }

  void emit(OutputFile* out) {
    for (auto it = iter(); it; ++it) {
      it->emit(out);
    }
  }
  // Invoke the emit() methods of each element in the list.

  size_t setOffset(size_t ofs) {
    for (auto& node : list_) ofs = node.setOffset(ofs);

    return ofs;
  }

  // Set the offsets of each element of the list based on the
  // start of the list being at offset 'ofs'.

  TList<T>::iterator iter() { return list_.begin(); }

  TList<T>::iterator begin() { return list_.begin(); }
  TList<T>::iterator end() { return list_.end(); }

  TList<T>::iterator find(T* node) { return list_.findIter(node); }

  T* addFront(std::unique_ptr<T> node) {
    return list_.addFront(std::move(node));
  }

  template <class U, class... Args>
    requires std::convertible_to<U*, T*>
  U* newNode(Args&&... args) {
    auto node = std::make_unique<U>(std::forward<Args>(args)...);
    auto* node_ptr = node.get();
    list_.addBack(std::move(node));
    return node_ptr;
  }

  template <class U, class... Args>
    requires std::convertible_to<U*, T*>
  U* newNodeBefore(ANode* before, Args&&... args) {
    auto node = std::make_unique<U>(std::forward<Args>(args)...);
    auto node_ptr = node.get();
    list_.findIter(before).addBefore(std::move(node));
    return node_ptr;
  }

 private:
  friend class FixupList;
  TList<T> list_;
};

struct AList : public AListBase<ANode> {};

struct AOpList : public AListBase<ANOpCode> {
  ANOpCode* nextOp(ANOpCode* start);
  // Return a pointer to the next opcode node after 'start' in
  // the list or NULL if there are none.
};

extern bool gShrink;

#endif
