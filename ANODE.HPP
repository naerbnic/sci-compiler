//	anode.hpp
// 	assembly nodes

#ifndef ANODE_HPP
#define ANODE_HPP

#ifndef ALIST_HPP
#include	"alist.hpp"
#endif

class OutputFile;

// Sizes of parameters
#define	OPSIZE		1
#define	BYTESIZE		2
#define	WORDSIZE		3

class ANode;
class ANReference;
class Symbol;

struct ANReference {
// This class is merged into subclasses of ANode via multiple inheritance
// as a mechanism for dealing with forward references to a symbol.  If the
// symbol being referenced has been defined, the 'target' property points
// to the ANode for the symbol.  Otherwise the symbol points to a list of
// ANReferences (linked through the 'backlink' property) which are waiting
// for the definition of the symbol.

	ANReference();

	virtual	void	backpatch(ANode*);
						// Called when a symbol is defined.  It walks back through
						// the list of references waiting for its definition,
						// pointing their 'target' properties at the ANode of the
						// symbol.

	void				addBackpatch(Symbol*);
						// Called when a reference is made to a symbol which
						// is not defined.  It adds this reference to the list of
						//	those waiting for the symbol definition.

	union {
		ANode*			target;		// pointer to thing being referenced
		ANReference*	backLink;	// backpatch link
	};
	Symbol*	sym;						// symbol of thing being referenced
};

struct ANode : LNode {
// An ANode (assembly node) is the construct generated by compiling a portion
// of the parse tree of the module.  It contains the essential information
// to generate the actual object code for the module.  The nodes are kept
// in an AList.

	ANode(AList* list = curList);
		// Creates an ANode and adds it to the list (default is the current
		// list in 'curList').

	ANode(AList* list, ANode* before);
		// Creates an ANode and adds it to the list before element 'before'.

	virtual ~ANode() {};

	virtual size_t	size();
						// Returns the number of bytes of object code generated
						// by the node.  This may change for a given node - for
						// example a branch node may change from a word to a byte
						// length branch because of optimizations.

	virtual size_t	setOffset(size_t ofs);
						// Sets the 'offset' property of the node to the offset
						// passed, and (using size()) returns the offset of the
						// byte following the node.

	virtual void	list();
						// Writes a representation of the node to the listing file.

	virtual void	emit(OutputFile*);
						// Emits the object code for the node to the output file.

	virtual Bool	optimize();
						// Applies some optimizations to the node.  This is not
						// really implemented for each node type yet -- most
						// optimization is done in OptimizeProc() in optimize.cpp.

	size_t offset;	// offset of node in file
};

struct ANDispatch :  ANode, ANReference
// The ANDispatch class serves as the members of the dispatch table to
// publicly defined procedures and objects.  There is one generated for
// each line in the (public ...) statement in SCI.  These are added to
// the 'dispTbl' dispatch table, set up in InitAsm().
{
	size_t	size();
	void		list();
	void		emit(OutputFile*);
	void		backpatch(ANode* dest);
};

struct ANWord : ANode
// An ANWord is the node used to generate an arbitrary word.  It is often
// used as a member of an ANTable, but can also appear directly in the
// objcode output.  The property 'value' contains the value of the word.
{
	ANWord(int v = 0);
	ANWord(AList* list, int v = 0);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	int		value;
};

struct ANTable : ANode
// An ANTable is a collection of ANodes that go together in some way.
// It is used to build objects, dispatch tables, etc.  When created, it
// saves a pointer to the list currently being added to in its 'oldList'
// property, then sets the current list to its own internal list.  The
// finish() method must be called when the table is completed to restore
// the original list as the current one.
{
	ANTable(char* nameStr, ANode* before = 0);

	size_t	size();
	size_t	setOffset(size_t ofs);
	void		list();
	void		emit(OutputFile*);
	void		finish();

	char*		name;			// name of table (values follow)
	AList		entries;		// list of entries in the table
	AList*	oldList;		// list active when table was created
};

struct ANObjTable : ANTable
// ANObjTable sub-classes ANTable to have the table added before the first
// instance of code in the hunk list.
{
	ANObjTable(char* nameStr);
};

class Text;

struct ANText : ANode
// The ANText class represents a text string.
{
	ANText(Text* tp);

	size_t	setOffset(size_t ofs);	// set offset to ofs, return new ofs
	size_t	size();
	void		list();
	void		emit(OutputFile*);

	Text*		text;
};

struct ANObject : ANode
// The ANObject class is the target of a reference to an instance or class.
// It generates nothing in the object code file.  The object itself is built
// up of ANTables containing properties, method dispatch vectors, etc.
{
	ANObject(Symbol* s, int n, ANode* before = 0);

	void		list();

	Symbol*	sym;
	int		num;
};

struct ANCodeBlk : ANode
// The ANCodeBlk class represents the code of a procedure or method.
// Like ANTable, it changes the list to which ANodes are added to its
// own internal list.  Therefore the finish() method must be called to
// reset the current list back to its original value when the code is
// complete.
{
	ANCodeBlk(Symbol* s);

	size_t	size();
	void		emit(OutputFile*);
	size_t	setOffset(size_t ofs);
	void		finish();
	Bool		optimize();

	Symbol*	sym;
	AList		code;
	AList*	oldList;
};

struct ANMethCode : ANCodeBlk
// ANMethCode is just a listing-specific subclass of ANCodeBlk, which
// generates "Method" rather than "Procedure" in the listing.
{
	ANMethCode(Symbol* s);

	void		list();

	Symbol*	objSym;	// pointer to symbol of object which this is a
							// method for
};

struct ANProcCode : ANCodeBlk
// ANProcCode is just a listing-specific subclass of ANCodeBlk, which
// generates "Procedure" rather than "Method" in the listing.
{
	ANProcCode(Symbol* s) : ANCodeBlk(s) {}

	void		list();
};

struct ANProp : ANode
// ANProp is the base class representing the properties of an object.
// Its method uses the virtual methods desc() and value() to deal with
// the differences between the various property types.
{
	ANProp(Symbol* sp, int v);

	virtual	char*		desc() = 0;		// return descriptive string
	virtual	uint		value() = 0;	// return value of selector

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	Symbol*	sym;							// pointer to selector's symbol
	int		val;							// value of selector
};

struct ANIntProp : ANProp
// A subclass of ANProp which represents integer properties.
{
	ANIntProp(Symbol* sp, int v) : ANProp(sp, v) {}

	char*		desc();		// return descriptive string
	uint		value();		// return value of selector
};

struct ANTextProp : ANProp
// A subclass of ANProp which represents text properties.
{
	ANTextProp(Symbol* sp, int v);

	void		emit(OutputFile*);
	char*		desc();		// return descriptive string
	uint		value();		// return value of selector
};

struct ANOfsProp : ANProp
// A subclass of ANProp which represents an offset to an object table.
{
	ANOfsProp(Symbol* sp) : ANProp(sp, 0) {}

	char*		desc();
	uint		value();

	ANode*	target;
};

struct ANMethod : ANProp
// A subclass of ANProp which represents methods.
{
	ANMethod(Symbol* sp, ANMethCode* mp);

	char*		desc();			// return descriptive string
	uint		value();			// return value of selector

	ANMethCode	*method;
};

struct ANOpCode : ANode
// This is the generic class for an opcode taking no parameters.  Opcodes
// requiring parameters are subclassed from this.  The property 'op' contains
// the opcode.
{
	ANOpCode() {}
	ANOpCode(uint o);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	uint		op;		// type of operator
};

class ANLabel : public ANOpCode
// The ANLabel class is not really an opcode (since it generates no object
// code), but is the target of branches.  It is subclassed from ANOpCode for
// reasons of polymorphism (so that we can walk down lists of ANOpCodes
// including ANLabels).
// The property 'number' is the number of the label.  It is used in the
// listing so that branches can be mapped to targets.
// The property 'nextLabel' keeps track of the number of the next label
// to be generated by 'new'.  This is reset to zero with the 'reset()'
// method at the start of each procedure and method.
{
public:
	ANLabel();

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	uint		number;	// label number

	static void	reset() {nextLabel = 0;}

private:
	static uint	nextLabel;						// label number of next label
};

struct ANOpUnsign : ANOpCode
// The ANOpUnsign class is an ANOpcode which takes an unsigned integer
// as the argument to the opcode.
{
	ANOpUnsign(uint o, uint v);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	uint		value;
	Symbol*	sym;
};

struct ANOpSign : ANOpCode
// The ANOpSign class is an ANOpcode which takes a signed integer as the
// argument to the opcode.
{
	ANOpSign(uint o, int v);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	int		value;
	Symbol*	sym;
};

struct ANOpExtern : ANOpCode
// The ANOpExtern class describes a call to an external proceedure.
{
	ANOpExtern(Symbol* s, uint m, uint e);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	uint		module;		// module # of destination
	uint		entry;		// entry # of destination
	uint		numArgs;		// number of arguments
	Symbol*	sym;
};

struct ANCall : ANOpCode, public ANReference
// The ANCall class describes a call to a procedure in the current module.
{
	ANCall(Symbol* s);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	uint		numArgs;		// number of arguments
};

struct ANBranch : ANOpCode, ANReference
// The ANBranch class represents a branch opcode.  The 'target' property
// of the ANReference portion is the ANode (actually the ANLabel) to which
// to branch.
{
	ANBranch(uint o);

	size_t	size();
	void		list();
	void		emit(OutputFile*);
};

struct ANVarAccess : ANOpCode
// The ANVarAccess class represents access to variables.  The 'op' property
// (inherited from ANOpCode) contains the type of access (load or store),
// the 'addr' property the offset of the variable in the appropriate
// variable block (global, local, or temporary).
{
	ANVarAccess(uint o, uint a);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	uint		addr;		// variable address
	Symbol*	sym;		// symbol of variable name
};

struct ANOpOfs : ANOpCode
// The ANOpOfs class gives the offset of a text string in
// its block of the object code.
{
	ANOpOfs(uint o);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	size_t	ofs;		// the offset
};

struct ANObjID : ANOpCode, ANReference
// The ANObjID class represents a reference to an object.  In the object
// code, it is just the offset of the object within the code segment.
// In the interpreter this gets fixed up at load time so that the opcode
// generates the address of the object in the heap.
{
	ANObjID(Symbol* sym);

	size_t	size();
	void		list();
	void		emit(OutputFile*);
};

struct ANEffctAddr : ANVarAccess
// The ANEffctAddr class loads the accumulator with the address of
// a variable.  The type of variable is determined by the value of
// the property 'eaType'.
{
	ANEffctAddr(uint o, uint a, uint t);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	uint		eaType;	// type of access
};

struct ANSend : ANOpCode
// The ANSend class represents a send to an object.
{
	ANSend(uint o);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	uint		numArgs;
};

struct ANSuper : ANSend
// The ANSuper class represents a send to the superclass whose number is
// 'classNum'.
{
	ANSuper(Symbol* s, uint c);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

	uint		classNum;
	Symbol*	sym;
};

class VarList;

class ANVars : public ANode
// The ANVars class is used to generate the block of variables for the
// module.
{
public:
	ANVars(VarList&);

	size_t	size();
	void		list();
	void		emit(OutputFile*);

protected:
	VarList&	theVars;
};

struct ANFixup : ANode {
// The ANFixup class is used to generate the block of fixups for the particular
// load module.

	ANFixup();

	size_t	size();
	void		list();
	void		emit(OutputFile*);
};

struct ANFileName : ANOpCode {
	//	contains the name of this script's source file for debugging

	ANFileName(const char* name);
	~ANFileName();
	
	void		list();
	void		emit(OutputFile*);
	size_t	size();

protected:
	const char*	name;
};

struct ANLineNum : ANOpCode {
	//	contains the current line number

	ANLineNum(int num);

	void		list();
	void		emit(OutputFile*);
	size_t	size();

protected:
	int		num;
};

extern ANCodeBlk*	codeStart;
extern size_t		curOfs;
extern int			textStart;

#endif

