//	alist.hpp
// 	definitions for assembly

#ifndef ALIST_HPP
#define ALIST_HPP

#include <cstddef>
#include <cstdint>
#include <utility>
#include <vector>

#include "list.hpp"

struct ANOpCode;
class OutputFile;
struct AList;

struct ANode : TNode {
  // An ANode (assembly node) is the construct generated by compiling a portion
  // of the parse tree of the module.  It contains the essential information
  // to generate the actual object code for the module.  The nodes are kept
  // in an AList.

  virtual ~ANode() = default;

  virtual size_t size();
  // Returns the number of bytes of object code generated
  // by the node.  This may change for a given node - for
  // example a branch node may change from a word to a byte
  // length branch because of optimizations.

  virtual size_t setOffset(size_t ofs);
  // Sets the 'offset' property of the node to the offset
  // passed, and (using size()) returns the offset of the
  // byte following the node.

  virtual void list();
  // Writes a representation of the node to the listing file.

  virtual void emit(OutputFile*);
  // Emits the object code for the node to the output file.

  virtual bool optimize();
  // Applies some optimizations to the node.  This is not
  // really implemented for each node type yet -- most
  // optimization is done in OptimizeProc() in optimize.cpp.

  size_t offset;  // offset of node in file
};

class AListIter {
  // AListIter is an iterator for the AList class.
 public:
  ANode* get() const;
  void advance();
  explicit operator bool();
  ANode* operator->();

  AListIter next() const;
  std::unique_ptr<ANode> remove();
  ANode* replaceWith(std::unique_ptr<ANode> nn);

  // Return true if the current node is an opcode with the
  // given opcode.
  bool isOp(uint32_t op) const;

 private:
  friend struct AList;
  AListIter(TList<ANode>::iterator iter) : iter_(std::move(iter)) {}
  TList<ANode>::iterator iter_;
};

struct AList {
  // AList (assembly list) is a list of ANodes (assembly nodes).

  ANOpCode* nextOp(ANode* start);
  // Return a pointer to the next opcode node after 'start' in
  // the list or NULL if there are none.

  size_t size();
  // Return the number of bytes of code generated by the opcodes
  // in this list.

  void list();
  // List a header for this AList, then invoke the list() methods
  // of each element in the list.

  void emit(OutputFile*);
  // Invoke the emit() methods of each element in the list.

  size_t setOffset(size_t ofs);
  // Set the offsets of each element of the list based on the
  // start of the list being at offset 'ofs'.

  void optimize();
  // Do any possible optimizations on this list.  Currently
  // only applies to subclass CodeList.

  AListIter iter() { return AListIter(list_.begin()); }

  void addBefore(ANode* ln, std::unique_ptr<ANode> nn) {
    list_.findIter(ln).addBefore(std::move(nn));
  }

  template <class T, class... Args>
  T* newNode(Args&&... args) {
    auto node = std::make_unique<T>(std::forward<Args>(args)...);
    auto* node_ptr = node.get();
    list_.addBack(std::move(node));
    return node_ptr;
  }

  template <class T, class... Args>
  T* newNodeBefore(ANode* before, Args&&... args) {
    auto node = std::make_unique<T>(std::forward<Args>(args)...);
    auto node_ptr = node.get();
    list_.findIter(before).addBefore(std::move(node));
    return node_ptr;
  }

 protected:
  friend class FixupList;
  TList<ANode> list_;
};

class FixupList {
  // A FixupList is an AList which has elements in it which need to be relocated
  // by the interpreter at load time.  It builds a table of offsets needing
  // relocation which is appended to the end of the object code being generated.
 public:
  FixupList();
  ~FixupList();

  void clear();
  void list();
  void emit(OutputFile*);
  size_t setOffset(size_t ofs);

  // Increment the number of elements needing fixup.  This is
  // called each time we generate an ANode requiring fixup.

  void initFixups();
  // Called once the module has been compiled to allocate space
  // for the fixup table based on 'numFixups'.

  void listFixups();
  // List the fixup table.

  void emitFixups(OutputFile*);
  // Emit the fixup table to the object file.

  void addFixup(size_t ofs);
  // The word at offset 'ofs' in the object file needs relocation.
  // Add the offset to the fixup table.

  ANode* front() { return down_cast<ANode>(list_.list_.frontPtr()); }

  void addAfter(ANode* ln, std::unique_ptr<ANode> nn) {
    list_.list_.findIter(ln).addAfter(std::move(nn));
  }

  bool contains(ANode* ln) { return list_.list_.contains(ln); }

  template <class T, class... Args>
  T* newNode(Args&&... args) {
    auto node = std::make_unique<T>(std::forward<Args>(args)...);
    auto* node_ptr = node.get();
    list_.list_.addBack(std::move(node));
    return node_ptr;
  }

  AList* getList() { return &list_; }

 protected:
  AList list_;
  std::vector<size_t> fixups;  // storage for fixup values
  size_t fixOfs;               // offset of start of fixups
};

struct CodeList : FixupList {
  // The CodeList class specializes the FixupList class for actual p-code,
  // which is the only sort of AList currently optimized.

  void optimize();
};

extern bool addNodesToList;
extern AList* curList;
extern bool noOptimize;
extern bool shrink;

#endif
