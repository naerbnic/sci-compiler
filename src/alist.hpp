//	alist.hpp
// 	definitions for assembly

#ifndef ALIST_HPP
#define ALIST_HPP

#include <cstddef>
#include <cstdint>
#include <optional>
#include <utility>
#include <vector>

#include "list.hpp"
#include "listing.hpp"

struct ANOpCode;
class OutputFile;

struct ANode : TNode {
  // An ANode (assembly node) is the construct generated by compiling a portion
  // of the parse tree of the module.  It contains the essential information
  // to generate the actual object code for the module.  The nodes are kept
  // in an AList.

  virtual ~ANode() = default;

  virtual size_t size();
  // Returns the number of bytes of object code generated
  // by the node.  This may change for a given node - for
  // example a branch node may change from a word to a byte
  // length branch because of optimizations.

  virtual size_t setOffset(size_t ofs);
  // Sets the 'offset' property of the node to the offset
  // passed, and (using size()) returns the offset of the
  // byte following the node.

  virtual void list(ListingFile* listFile);
  // Writes a representation of the node to the listing file.

  virtual void emit(OutputFile*);
  // Emits the object code for the node to the output file.

  virtual bool optimize();
  // Applies some optimizations to the node.  This is not
  // really implemented for each node type yet -- most
  // optimization is done in OptimizeProc() in optimize.cpp.

  std::optional<size_t> offset;  // offset of node in file
};

struct ANOpCode : ANode
// This is the generic class for an opcode taking no parameters.  Opcodes
// requiring parameters are subclassed from this.  The property 'op' contains
// the opcode.
{
  ANOpCode() = default;
  ANOpCode(uint32_t o);

  size_t size();
  void list(ListingFile* listFile);
  void emit(OutputFile*);

  uint32_t op;  // type of operator
};

template <class T>
class AListBase {
 public:
  // AList (assembly list) is a list of ANodes (assembly nodes).

  size_t size() {
    size_t s = 0;
    for (auto it = iter(); it; ++it) s += it->size();
    return s;
  }
  // Return the number of bytes of code generated by the opcodes
  // in this list.

  void list(ListingFile* listFile) {
    for (auto it = iter(); it; ++it) it->list(listFile);
  }

  void emit(OutputFile* out) {
    for (auto it = iter(); it; ++it) {
      it->emit(out);
    }
  }
  // Invoke the emit() methods of each element in the list.

  size_t setOffset(size_t ofs) {
    for (auto& node : list_) ofs = node.setOffset(ofs);

    return ofs;
  }

  // Set the offsets of each element of the list based on the
  // start of the list being at offset 'ofs'.

  TList<T>::iterator iter() { return list_.begin(); }

  TList<T>::iterator begin() { return list_.begin(); }
  TList<T>::iterator end() { return list_.end(); }

  TList<T>::iterator find(T* node) { return list_.findIter(node); }

  template <class U, class... Args>
    requires std::convertible_to<U*, T*>
  U* newNode(Args&&... args) {
    auto node = std::make_unique<U>(std::forward<Args>(args)...);
    auto* node_ptr = node.get();
    list_.addBack(std::move(node));
    return node_ptr;
  }

  template <class U, class... Args>
    requires std::convertible_to<U*, T*>
  U* newNodeBefore(ANode* before, Args&&... args) {
    auto node = std::make_unique<U>(std::forward<Args>(args)...);
    auto node_ptr = node.get();
    list_.findIter(before).addBefore(std::move(node));
    return node_ptr;
  }

 private:
  friend class FixupList;
  TList<T> list_;
};

struct AList : public AListBase<ANode> {};

struct AOpList : public AListBase<ANOpCode> {
  ANOpCode* nextOp(ANOpCode* start);
  // Return a pointer to the next opcode node after 'start' in
  // the list or NULL if there are none.
};

class FixupList {
  // A FixupList is an AList which has elements in it which need to be relocated
  // by the interpreter at load time.  It builds a table of offsets needing
  // relocation which is appended to the end of the object code being generated.
 public:
  FixupList();
  ~FixupList();

  void clear();

  void list(ListingFile* listFile);
  void emit(OutputFile*);
  size_t setOffset(size_t ofs);

  // Increment the number of elements needing fixup.  This is
  // called each time we generate an ANode requiring fixup.

  void initFixups();
  // Called once the module has been compiled to allocate space
  // for the fixup table based on 'numFixups'.

  void listFixups(ListingFile* listFile);
  // List the fixup table.

  void emitFixups(OutputFile*);
  // Emit the fixup table to the object file.

  void addFixup(size_t ofs);
  // The word at offset 'ofs' in the object file needs relocation.
  // Add the offset to the fixup table.

  ANode* front() { return down_cast<ANode>(list_.list_.frontPtr()); }

  void addAfter(ANode* ln, std::unique_ptr<ANode> nn) {
    list_.list_.findIter(ln).addAfter(std::move(nn));
  }

  bool contains(ANode* ln) { return list_.list_.contains(ln); }

  template <class T, class... Args>
  T* newNode(Args&&... args) {
    auto node = std::make_unique<T>(std::forward<Args>(args)...);
    auto* node_ptr = node.get();
    list_.list_.addBack(std::move(node));
    return node_ptr;
  }

  AList* getList() { return &list_; }

 protected:
  AList list_;
  std::vector<size_t> fixups;  // storage for fixup values
  size_t fixOfs;               // offset of start of fixups
};

struct CodeList : FixupList {
  // The CodeList class specializes the FixupList class for actual p-code,
  // which is the only sort of AList currently optimized.

  void optimize();
};

extern bool gNoOptimize;
extern bool gShrink;

#endif
